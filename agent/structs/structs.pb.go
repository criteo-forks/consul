// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: structs.proto

package structs

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/golang/protobuf/ptypes/duration"

import time "time"
import github_com_hashicorp_consul_types "github.com/hashicorp/consul/types"

import github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// QueryMeta allows a query response to include potentially
// useful metadata about a query
type QueryMeta struct {
	// This is the index associated with the read
	Index uint64 `protobuf:"varint,1,opt,name=Index,proto3" json:""`
	// If AllowStale is used, this is time elapsed since
	// last contact between the follower and leader. This
	// can be used to gauge staleness.
	LastContact time.Duration `protobuf:"bytes,2,opt,name=LastContact,stdduration" json:""`
	// Used to indicate if there is a known leader node
	KnownLeader bool `protobuf:"varint,3,opt,name=KnownLeader,proto3" json:""`
	// Consistencylevel returns the consistency used to serve the query
	// Having `discovery_max_stale` on the agent can affect whether
	// the request was served by a leader.
	ConsistencyLevel string `protobuf:"bytes,4,opt,name=ConsistencyLevel,proto3" json:""`
}

func (m *QueryMeta) Reset()         { *m = QueryMeta{} }
func (m *QueryMeta) String() string { return proto.CompactTextString(m) }
func (*QueryMeta) ProtoMessage()    {}
func (*QueryMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_structs_90c2cf680e97d80b, []int{0}
}
func (m *QueryMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *QueryMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMeta.Merge(dst, src)
}
func (m *QueryMeta) XXX_Size() int {
	return m.Size()
}
func (m *QueryMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMeta.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMeta proto.InternalMessageInfo

// QueryOptions is used to specify various flags for read queries
type QueryOptions struct {
	// Token is the ACL token ID. If not provided, the 'anonymous'
	// token is assumed for backwards compatibility.
	Token string `protobuf:"bytes,1,opt,name=Token,proto3" json:"Token,omitempty"`
	// If set, wait until query exceeds given index. Must be provided
	// with MaxQueryTime.
	MinQueryIndex uint64 `protobuf:"varint,2,opt,name=MinQueryIndex,proto3" json:"MinQueryIndex,omitempty"`
	// Provided with MinQueryIndex to wait for change.
	MaxQueryTime time.Duration `protobuf:"bytes,3,opt,name=MaxQueryTime,stdduration" json:"MaxQueryTime"`
	// If set, any follower can service the request. Results
	// may be arbitrarily stale.
	AllowStale bool `protobuf:"varint,4,opt,name=AllowStale,proto3" json:"AllowStale,omitempty"`
	// If set, the leader must verify leadership prior to
	// servicing the request. Prevents a stale read.
	RequireConsistent bool `protobuf:"varint,5,opt,name=RequireConsistent,proto3" json:"RequireConsistent,omitempty"`
	// If set, the local agent may respond with an arbitrarily stale locally
	// cached response. The semantics differ from AllowStale since the agent may
	// be entirely partitioned from the servers and still considered "healthy" by
	// operators. Stale responses from Servers are also arbitrarily stale, but can
	// provide additional bounds on the last contact time from the leader. It's
	// expected that servers that are partitioned are noticed and replaced in a
	// timely way by operators while the same may not be true for client agents.
	UseCache bool `protobuf:"varint,6,opt,name=UseCache,proto3" json:"UseCache,omitempty"`
	// If set and AllowStale is true, will try first a stale
	// read, and then will perform a consistent read if stale
	// read is older than value.
	MaxStaleDuration time.Duration `protobuf:"bytes,7,opt,name=MaxStaleDuration,stdduration" json:"MaxStaleDuration"`
	// MaxAge limits how old a cached value will be returned if UseCache is true.
	// If there is a cached response that is older than the MaxAge, it is treated
	// as a cache miss and a new fetch invoked. If the fetch fails, the error is
	// returned. Clients that wish to allow for stale results on error can set
	// StaleIfError to a longer duration to change this behavior. It is ignored
	// if the endpoint supports background refresh caching. See
	// https://www.consul.io/api/index.html#agent-caching for more details.
	MaxAge time.Duration `protobuf:"bytes,8,opt,name=MaxAge,stdduration" json:"MaxAge"`
	// MustRevalidate forces the agent to fetch a fresh version of a cached
	// resource or at least validate that the cached version is still fresh. It is
	// implied by either max-age=0 or must-revalidate Cache-Control headers. It
	// only makes sense when UseCache is true. We store it since MaxAge = 0 is the
	// default unset value.
	MustRevalidate bool `protobuf:"varint,9,opt,name=MustRevalidate,proto3" json:"MustRevalidate,omitempty"`
	// StaleIfError specifies how stale the client will accept a cached response
	// if the servers are unavailable to fetch a fresh one. Only makes sense when
	// UseCache is true and MaxAge is set to a lower, non-zero value. It is
	// ignored if the endpoint supports background refresh caching. See
	// https://www.consul.io/api/index.html#agent-caching for more details.
	StaleIfError time.Duration `protobuf:"bytes,10,opt,name=StaleIfError,stdduration" json:"StaleIfError"`
	// Filter specifies the go-bexpr filter expression to be used for
	// filtering the data prior to returning a response
	Filter string `protobuf:"bytes,11,opt,name=Filter,proto3" json:"Filter,omitempty"`
}

func (m *QueryOptions) Reset()         { *m = QueryOptions{} }
func (m *QueryOptions) String() string { return proto.CompactTextString(m) }
func (*QueryOptions) ProtoMessage()    {}
func (*QueryOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_structs_90c2cf680e97d80b, []int{1}
}
func (m *QueryOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *QueryOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryOptions.Merge(dst, src)
}
func (m *QueryOptions) XXX_Size() int {
	return m.Size()
}
func (m *QueryOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryOptions.DiscardUnknown(m)
}

var xxx_messageInfo_QueryOptions proto.InternalMessageInfo

// QuerySource is used to pass along information about the source node
// in queries so that we can adjust the response based on its network
// coordinates.
type QuerySource struct {
	Datacenter string `protobuf:"bytes,1,opt,name=Datacenter,proto3" json:"Datacenter,omitempty"`
	Segment    string `protobuf:"bytes,2,opt,name=Segment,proto3" json:"Segment,omitempty"`
	Node       string `protobuf:"bytes,3,opt,name=Node,proto3" json:"Node,omitempty"`
	Ip         string `protobuf:"bytes,4,opt,name=Ip,proto3" json:"Ip,omitempty"`
}

func (m *QuerySource) Reset()         { *m = QuerySource{} }
func (m *QuerySource) String() string { return proto.CompactTextString(m) }
func (*QuerySource) ProtoMessage()    {}
func (*QuerySource) Descriptor() ([]byte, []int) {
	return fileDescriptor_structs_90c2cf680e97d80b, []int{2}
}
func (m *QuerySource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *QuerySource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySource.Merge(dst, src)
}
func (m *QuerySource) XXX_Size() int {
	return m.Size()
}
func (m *QuerySource) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySource.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySource proto.InternalMessageInfo

// ServiceSpecificRequest is used to query about a specific service
type ServiceSpecificRequest struct {
	Datacenter      string            `protobuf:"bytes,1,opt,name=Datacenter,proto3" json:"Datacenter,omitempty"`
	NodeMetaFilters map[string]string `protobuf:"bytes,2,rep,name=NodeMetaFilters" json:"NodeMetaFilters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ServiceName     string            `protobuf:"bytes,3,opt,name=ServiceName,proto3" json:"ServiceName,omitempty"`
	// DEPRECATED (singular-service-tag) - remove this when backwards RPC compat
	// with 1.2.x is not required.
	ServiceTag     string      `protobuf:"bytes,4,opt,name=ServiceTag,proto3" json:"ServiceTag,omitempty"`
	ServiceTags    []string    `protobuf:"bytes,5,rep,name=ServiceTags" json:"ServiceTags,omitempty"`
	ServiceAddress string      `protobuf:"bytes,6,opt,name=ServiceAddress,proto3" json:"ServiceAddress,omitempty"`
	TagFilter      bool        `protobuf:"varint,7,opt,name=TagFilter,proto3" json:"TagFilter,omitempty"`
	Source         QuerySource `protobuf:"bytes,8,opt,name=Source" json:"Source"`
	// Connect if true will only search for Connect-compatible services.
	Connect      bool `protobuf:"varint,9,opt,name=Connect,proto3" json:"Connect,omitempty"`
	QueryOptions `protobuf:"bytes,10,opt,name=QueryOptions,embedded=QueryOptions" json:"QueryOptions"`
}

func (m *ServiceSpecificRequest) Reset()         { *m = ServiceSpecificRequest{} }
func (m *ServiceSpecificRequest) String() string { return proto.CompactTextString(m) }
func (*ServiceSpecificRequest) ProtoMessage()    {}
func (*ServiceSpecificRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_structs_90c2cf680e97d80b, []int{3}
}
func (m *ServiceSpecificRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceSpecificRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceSpecificRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ServiceSpecificRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceSpecificRequest.Merge(dst, src)
}
func (m *ServiceSpecificRequest) XXX_Size() int {
	return m.Size()
}
func (m *ServiceSpecificRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceSpecificRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceSpecificRequest proto.InternalMessageInfo

// RaftIndex is used to track the index used while creating
// or modifying a given struct type.
type RaftIndex struct {
	CreateIndex uint64 `protobuf:"varint,1,opt,name=CreateIndex,proto3" json:"CreateIndex,omitempty" bexpr:"-"`
	ModifyIndex uint64 `protobuf:"varint,2,opt,name=ModifyIndex,proto3" json:"ModifyIndex,omitempty" bexpr:"-"`
}

func (m *RaftIndex) Reset()         { *m = RaftIndex{} }
func (m *RaftIndex) String() string { return proto.CompactTextString(m) }
func (*RaftIndex) ProtoMessage()    {}
func (*RaftIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_structs_90c2cf680e97d80b, []int{4}
}
func (m *RaftIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RaftIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftIndex.Merge(dst, src)
}
func (m *RaftIndex) XXX_Size() int {
	return m.Size()
}
func (m *RaftIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftIndex.DiscardUnknown(m)
}

var xxx_messageInfo_RaftIndex proto.InternalMessageInfo

// Used to return information about a node
type Node struct {
	ID              github_com_hashicorp_consul_types.NodeID `protobuf:"bytes,1,opt,name=ID,proto3,casttype=github.com/hashicorp/consul/types.NodeID" json:""`
	Node            string                                   `protobuf:"bytes,2,opt,name=Node,proto3" json:""`
	Address         string                                   `protobuf:"bytes,3,opt,name=Address,proto3" json:""`
	Datacenter      string                                   `protobuf:"bytes,4,opt,name=Datacenter,proto3" json:""`
	TaggedAddresses map[string]string                        `protobuf:"bytes,5,rep,name=TaggedAddresses" json:"" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Meta            map[string]string                        `protobuf:"bytes,6,rep,name=Meta" json:"" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	RaftIndex       `protobuf:"bytes,7,opt,name=RaftIndex,embedded=RaftIndex" json:"" bexpr:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_structs_90c2cf680e97d80b, []int{5}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(dst, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

// Weights represent the weight used by DNS for a given status
type Weights struct {
	Passing int `protobuf:"varint,1,opt,name=Passing,proto3,casttype=int" json:""`
	Warning int `protobuf:"varint,2,opt,name=Warning,proto3,casttype=int" json:""`
}

func (m *Weights) Reset()         { *m = Weights{} }
func (m *Weights) String() string { return proto.CompactTextString(m) }
func (*Weights) ProtoMessage()    {}
func (*Weights) Descriptor() ([]byte, []int) {
	return fileDescriptor_structs_90c2cf680e97d80b, []int{6}
}
func (m *Weights) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Weights) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Weights.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Weights) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Weights.Merge(dst, src)
}
func (m *Weights) XXX_Size() int {
	return m.Size()
}
func (m *Weights) XXX_DiscardUnknown() {
	xxx_messageInfo_Weights.DiscardUnknown(m)
}

var xxx_messageInfo_Weights proto.InternalMessageInfo

// CheckType is used to create either the CheckMonitor or the CheckTTL.
// The following types are supported: Script, HTTP, TCP, Docker, TTL, GRPC,
// Alias. Script,
// HTTP, Docker, TCP and GRPC all require Interval. Only one of the types may
// to be provided: TTL or Script/Interval or HTTP/Interval or TCP/Interval or
// Docker/Interval or GRPC/Interval or AliasService.
type CheckType struct {
	CheckID           github_com_hashicorp_consul_types.CheckID `protobuf:"bytes,1,opt,name=CheckID,proto3,casttype=github.com/hashicorp/consul/types.CheckID" json:""`
	Name              string                                    `protobuf:"bytes,2,opt,name=Name,proto3" json:""`
	Status            string                                    `protobuf:"bytes,3,opt,name=Status,proto3" json:""`
	Notes             string                                    `protobuf:"bytes,4,opt,name=Notes,proto3" json:""`
	ScriptArgs        []string                                  `protobuf:"bytes,5,rep,name=ScriptArgs" json:""`
	HTTP              string                                    `protobuf:"bytes,6,opt,name=HTTP,proto3" json:""`
	Header            Headers                                   `protobuf:"bytes,20,opt,name=Header,proto3,customtype=Headers" json:""`
	Method            string                                    `protobuf:"bytes,7,opt,name=Method,proto3" json:""`
	TCP               string                                    `protobuf:"bytes,8,opt,name=TCP,proto3" json:""`
	Interval          time.Duration                             `protobuf:"bytes,9,opt,name=Interval,stdduration" json:""`
	AliasNode         string                                    `protobuf:"bytes,10,opt,name=AliasNode,proto3" json:""`
	AliasService      string                                    `protobuf:"bytes,11,opt,name=AliasService,proto3" json:""`
	DockerContainerID string                                    `protobuf:"bytes,12,opt,name=DockerContainerID,proto3" json:""`
	Shell             string                                    `protobuf:"bytes,13,opt,name=Shell,proto3" json:""`
	GRPC              string                                    `protobuf:"bytes,14,opt,name=GRPC,proto3" json:""`
	GRPCUseTLS        bool                                      `protobuf:"varint,15,opt,name=GRPCUseTLS,proto3" json:""`
	TLSSkipVerify     bool                                      `protobuf:"varint,16,opt,name=TLSSkipVerify,proto3" json:""`
	Timeout           time.Duration                             `protobuf:"bytes,17,opt,name=Timeout,stdduration" json:""`
	TTL               time.Duration                             `protobuf:"bytes,18,opt,name=TTL,stdduration" json:""`
	// DeregisterCriticalServiceAfter, if >0, will cause the associated
	// service, if any, to be deregistered if this check is critical for
	// longer than this duration.
	DeregisterCriticalServiceAfter time.Duration `protobuf:"bytes,19,opt,name=DeregisterCriticalServiceAfter,stdduration" json:""`
}

func (m *CheckType) Reset()         { *m = CheckType{} }
func (m *CheckType) String() string { return proto.CompactTextString(m) }
func (*CheckType) ProtoMessage()    {}
func (*CheckType) Descriptor() ([]byte, []int) {
	return fileDescriptor_structs_90c2cf680e97d80b, []int{7}
}
func (m *CheckType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CheckType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckType.Merge(dst, src)
}
func (m *CheckType) XXX_Size() int {
	return m.Size()
}
func (m *CheckType) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckType.DiscardUnknown(m)
}

var xxx_messageInfo_CheckType proto.InternalMessageInfo

// ServiceDefinition is used to JSON decode the Service definitions. For
// documentation on specific fields see NodeService which is better documented.
type ServiceDefinition struct {
	Kind              ServiceKind       `protobuf:"bytes,1,opt,name=Kind,proto3,casttype=ServiceKind" json:"Kind,omitempty"`
	ID                string            `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	Name              string            `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	Tags              []string          `protobuf:"bytes,4,rep,name=Tags" json:"Tags,omitempty"`
	Address           string            `protobuf:"bytes,5,opt,name=Address,proto3" json:"Address,omitempty"`
	Meta              map[string]string `protobuf:"bytes,6,rep,name=Meta" json:"Meta,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Port              int               `protobuf:"varint,7,opt,name=Port,proto3,casttype=int" json:"Port,omitempty"`
	Check             CheckType         `protobuf:"bytes,8,opt,name=Check" json:"Check"`
	Checks            []*CheckType      `protobuf:"bytes,9,rep,name=Checks" json:"Checks,omitempty"`
	Weights           *Weights          `protobuf:"bytes,10,opt,name=Weights" json:"Weights,omitempty"`
	Token             string            `protobuf:"bytes,11,opt,name=Token,proto3" json:"Token,omitempty"`
	EnableTagOverride bool              `protobuf:"varint,12,opt,name=EnableTagOverride,proto3" json:"EnableTagOverride,omitempty"`
	// DEPRECATED (ProxyDestination) - remove this when removing ProxyDestination
	// ProxyDestination is deprecated in favor of Proxy.DestinationServiceName
	ProxyDestination string `protobuf:"bytes,13,opt,name=ProxyDestination,proto3" json:"ProxyDestination,omitempty"`
	// Proxy is the configuration set for Kind = connect-proxy. It is mandatory in
	// that case and an error to be set for any other kind. This config is part of
	// a proxy service definition and is distinct from but shares some fields with
	// the Connect.Proxy which configures a managed proxy as part of the actual
	// service's definition. This duplication is ugly but seemed better than the
	// alternative which was to re-use the same struct fields for both cases even
	// though the semantics are different and the non-shared fields make no sense
	// in the other case. ProxyConfig may be a more natural name here, but it's
	// confusing for the UX because one of the fields in ConnectProxyConfig is
	// also called just "Config"
	Proxy   *ConnectProxyConfig `protobuf:"bytes,14,opt,name=Proxy" json:"Proxy,omitempty"`
	Connect *ServiceConnect     `protobuf:"bytes,15,opt,name=Connect" json:"Connect,omitempty"`
}

func (m *ServiceDefinition) Reset()         { *m = ServiceDefinition{} }
func (m *ServiceDefinition) String() string { return proto.CompactTextString(m) }
func (*ServiceDefinition) ProtoMessage()    {}
func (*ServiceDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptor_structs_90c2cf680e97d80b, []int{8}
}
func (m *ServiceDefinition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceDefinition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceDefinition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ServiceDefinition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceDefinition.Merge(dst, src)
}
func (m *ServiceDefinition) XXX_Size() int {
	return m.Size()
}
func (m *ServiceDefinition) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceDefinition.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceDefinition proto.InternalMessageInfo

type HealthCheckDefinition struct {
	HTTP                           string        `protobuf:"bytes,1,opt,name=HTTP,proto3" json:",omitempty"`
	TLSSkipVerify                  bool          `protobuf:"varint,2,opt,name=TLSSkipVerify,proto3" json:",omitempty"`
	Header                         Headers       `protobuf:"bytes,3,opt,name=Header,proto3,customtype=Headers" json:",omitempty"`
	Method                         string        `protobuf:"bytes,4,opt,name=Method,proto3" json:",omitempty"`
	TCP                            string        `protobuf:"bytes,5,opt,name=TCP,proto3" json:",omitempty"`
	Interval                       time.Duration `protobuf:"bytes,6,opt,name=Interval,stdduration" json:",omitempty"`
	Timeout                        time.Duration `protobuf:"bytes,7,opt,name=Timeout,stdduration" json:",omitempty"`
	DeregisterCriticalServiceAfter time.Duration `protobuf:"bytes,8,opt,name=DeregisterCriticalServiceAfter,stdduration" json:",omitempty"`
}

func (m *HealthCheckDefinition) Reset()         { *m = HealthCheckDefinition{} }
func (m *HealthCheckDefinition) String() string { return proto.CompactTextString(m) }
func (*HealthCheckDefinition) ProtoMessage()    {}
func (*HealthCheckDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptor_structs_90c2cf680e97d80b, []int{9}
}
func (m *HealthCheckDefinition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthCheckDefinition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HealthCheckDefinition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HealthCheckDefinition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthCheckDefinition.Merge(dst, src)
}
func (m *HealthCheckDefinition) XXX_Size() int {
	return m.Size()
}
func (m *HealthCheckDefinition) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthCheckDefinition.DiscardUnknown(m)
}

var xxx_messageInfo_HealthCheckDefinition proto.InternalMessageInfo

// HealthCheck represents a single check on a given node
type HealthCheck struct {
	Node        string                                    `protobuf:"bytes,1,opt,name=Node,proto3" json:""`
	CheckID     github_com_hashicorp_consul_types.CheckID `protobuf:"bytes,2,opt,name=CheckID,proto3,casttype=github.com/hashicorp/consul/types.CheckID" json:""`
	Name        string                                    `protobuf:"bytes,3,opt,name=Name,proto3" json:""`
	Status      string                                    `protobuf:"bytes,4,opt,name=Status,proto3" json:""`
	Notes       string                                    `protobuf:"bytes,5,opt,name=Notes,proto3" json:""`
	Output      string                                    `protobuf:"bytes,6,opt,name=Output,proto3" json:""`
	ServiceID   string                                    `protobuf:"bytes,7,opt,name=ServiceID,proto3" json:""`
	ServiceName string                                    `protobuf:"bytes,8,opt,name=ServiceName,proto3" json:""`
	ServiceTags []string                                  `protobuf:"bytes,9,rep,name=ServiceTags" json:""`
	Definition  HealthCheckDefinition                     `protobuf:"bytes,10,opt,name=Definition" json:"" bexpr:"-"`
	RaftIndex   `protobuf:"bytes,11,opt,name=RaftIndex,embedded=RaftIndex" json:"" bexpr:"-"`
}

func (m *HealthCheck) Reset()         { *m = HealthCheck{} }
func (m *HealthCheck) String() string { return proto.CompactTextString(m) }
func (*HealthCheck) ProtoMessage()    {}
func (*HealthCheck) Descriptor() ([]byte, []int) {
	return fileDescriptor_structs_90c2cf680e97d80b, []int{10}
}
func (m *HealthCheck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HealthCheck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HealthCheck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthCheck.Merge(dst, src)
}
func (m *HealthCheck) XXX_Size() int {
	return m.Size()
}
func (m *HealthCheck) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthCheck.DiscardUnknown(m)
}

var xxx_messageInfo_HealthCheck proto.InternalMessageInfo

// Upstream represents a single upstream dependency for a service or proxy. It
// describes the mechanism used to discover instances to communicate with (the
// Target) as well as any potential client configuration that may be useful such
// as load balancer options, timeouts etc.
type Upstream struct {
	// Destination fields are the required ones for determining what this upstream
	// points to. Depending on DestinationType some other fields below might
	// further restrict the set of instances allowable.
	//
	// DestinationType would be better as an int constant but even with custom
	// JSON marshallers it causes havoc with all the mapstructure mangling we do
	// on service definitions in various places.
	DestinationType      string `protobuf:"bytes,1,opt,name=DestinationType,proto3" json:"DestinationType,omitempty"`
	DestinationNamespace string `protobuf:"bytes,2,opt,name=DestinationNamespace,proto3" json:"DestinationNamespace,omitempty"`
	DestinationName      string `protobuf:"bytes,3,opt,name=DestinationName,proto3" json:"DestinationName,omitempty"`
	// Datacenter that the service discovery request should be run against. Note
	// for prepared queries, the actual results might be from a different
	// datacenter.
	Datacenter string `protobuf:"bytes,4,opt,name=Datacenter,proto3" json:"Datacenter,omitempty"`
	// LocalBindAddress is the ip address a side-car proxy should listen on for
	// traffic destined for this upstream service. Default if empty is 127.0.0.1.
	LocalBindAddress string `protobuf:"bytes,5,opt,name=LocalBindAddress,proto3" json:"LocalBindAddress,omitempty"`
	// LocalBindPort is the ip address a side-car proxy should listen on for
	// traffic
	// destined for this upstream service. Required.
	LocalBindPort int `protobuf:"varint,6,opt,name=LocalBindPort,proto3,casttype=int" json:"LocalBindPort,omitempty"`
	// Config is an opaque config that is specific to the proxy process being run.
	// It can be used to pass arbitrary configuration for this specific upstream
	// to the proxy.
	Config UntypedMap `protobuf:"bytes,7,opt,name=Config,proto3,customtype=UntypedMap" json:"Config" bexpr:"-"`
}

func (m *Upstream) Reset()      { *m = Upstream{} }
func (*Upstream) ProtoMessage() {}
func (*Upstream) Descriptor() ([]byte, []int) {
	return fileDescriptor_structs_90c2cf680e97d80b, []int{11}
}
func (m *Upstream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Upstream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Upstream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Upstream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Upstream.Merge(dst, src)
}
func (m *Upstream) XXX_Size() int {
	return m.Size()
}
func (m *Upstream) XXX_DiscardUnknown() {
	xxx_messageInfo_Upstream.DiscardUnknown(m)
}

var xxx_messageInfo_Upstream proto.InternalMessageInfo

// ConnectProxyConfig describes the configuration needed for any proxy managed
// or unmanaged. It describes a single logical service's listener and optionally
// upstreams and sidecar-related config for a single instance. To describe a
// centralized proxy that routed traffic for multiple services, a different one
// of these would be needed for each, sharing the same LogicalProxyID.
type ConnectProxyConfig struct {
	// DestinationServiceName is required and is the name of the service to accept
	// traffic for.
	DestinationServiceName string `protobuf:"bytes,1,opt,name=DestinationServiceName,proto3" json:"DestinationServiceName,omitempty"`
	// DestinationServiceID is optional and should only be specified for
	// "side-car" style proxies where the proxy is in front of just a single
	// instance of the service. It should be set to the service ID of the instance
	// being represented which must be registered to the same agent. It's valid to
	// provide a service ID that does not yet exist to avoid timing issues when
	// bootstrapping a service with a proxy.
	DestinationServiceID string `protobuf:"bytes,2,opt,name=DestinationServiceID,proto3" json:"DestinationServiceID,omitempty"`
	// LocalServiceAddress is the address of the local service instance. It is
	// optional and should only be specified for "side-car" style proxies. It will
	// default to 127.0.0.1 if the proxy is a "side-car" (DestinationServiceID is
	// set) but otherwise will be ignored.
	LocalServiceAddress string `protobuf:"bytes,3,opt,name=LocalServiceAddress,proto3" json:"LocalServiceAddress,omitempty"`
	// LocalServicePort is the port of the local service instance. It is optional
	// and should only be specified for "side-car" style proxies. It will default
	// to the registered port for the instance if the proxy is a "side-car"
	// (DestinationServiceID is set) but otherwise will be ignored.
	LocalServicePort int `protobuf:"varint,4,opt,name=LocalServicePort,proto3,casttype=int" json:"LocalServicePort,omitempty"`
	// Config is the arbitrary configuration data provided with the proxy
	// registration.
	Config UntypedMap `protobuf:"bytes,5,opt,name=Config,proto3,customtype=UntypedMap" json:",omitempty" bexpr:"-"`
	// Upstreams describes any upstream dependencies the proxy instance should
	// setup.
	Upstreams []Upstream `protobuf:"bytes,6,rep,name=Upstreams" json:",omitempty"`
}

func (m *ConnectProxyConfig) Reset()         { *m = ConnectProxyConfig{} }
func (m *ConnectProxyConfig) String() string { return proto.CompactTextString(m) }
func (*ConnectProxyConfig) ProtoMessage()    {}
func (*ConnectProxyConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_structs_90c2cf680e97d80b, []int{12}
}
func (m *ConnectProxyConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectProxyConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectProxyConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ConnectProxyConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectProxyConfig.Merge(dst, src)
}
func (m *ConnectProxyConfig) XXX_Size() int {
	return m.Size()
}
func (m *ConnectProxyConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectProxyConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectProxyConfig proto.InternalMessageInfo

// ServiceDefinitionConnectProxy is the connect proxy config  within a service
// registration. Note this is duplicated in config.ServiceConnectProxy and needs
// to be kept in sync.
type ServiceDefinitionConnectProxy struct {
	Command   []string   `protobuf:"bytes,1,rep,name=Command" json:",omitempty"`
	ExecMode  string     `protobuf:"bytes,2,opt,name=ExecMode,proto3" json:",omitempty"`
	Config    UntypedMap `protobuf:"bytes,3,opt,name=Config,proto3,customtype=UntypedMap" json:",omitempty"`
	Upstreams []Upstream `protobuf:"bytes,4,rep,name=Upstreams" json:",omitempty"`
}

func (m *ServiceDefinitionConnectProxy) Reset()         { *m = ServiceDefinitionConnectProxy{} }
func (m *ServiceDefinitionConnectProxy) String() string { return proto.CompactTextString(m) }
func (*ServiceDefinitionConnectProxy) ProtoMessage()    {}
func (*ServiceDefinitionConnectProxy) Descriptor() ([]byte, []int) {
	return fileDescriptor_structs_90c2cf680e97d80b, []int{13}
}
func (m *ServiceDefinitionConnectProxy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceDefinitionConnectProxy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceDefinitionConnectProxy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ServiceDefinitionConnectProxy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceDefinitionConnectProxy.Merge(dst, src)
}
func (m *ServiceDefinitionConnectProxy) XXX_Size() int {
	return m.Size()
}
func (m *ServiceDefinitionConnectProxy) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceDefinitionConnectProxy.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceDefinitionConnectProxy proto.InternalMessageInfo

// ServiceConnect are the shared Connect settings between all service
// definitions from the agent to the state store.
type ServiceConnect struct {
	// Native is true when this service can natively understand Connect.
	Native bool `protobuf:"varint,1,opt,name=Native,proto3" json:"Native,omitempty"`
	// Proxy configures a connect proxy instance for the service. This is
	// only used for agent service definitions and is invalid for non-agent
	// (catalog API) definitions.
	Proxy *ServiceDefinitionConnectProxy `protobuf:"bytes,2,opt,name=Proxy" json:"Proxy,omitempty" bexpr:"-"`
	// SidecarService is a nested Service Definition to register at the same time.
	// It's purely a convenience mechanism to allow specifying a sidecar service
	// along with the application service definition. It's nested nature allows
	// all of the fields to be defaulted which can reduce the amount of
	// boilerplate needed to register a sidecar service separately, but the end
	// result is identical to just making a second service registration via any
	// other means.
	SidecarService *ServiceDefinition `protobuf:"bytes,3,opt,name=SidecarService" json:"SidecarService,omitempty" bexpr:"-"`
}

func (m *ServiceConnect) Reset()         { *m = ServiceConnect{} }
func (m *ServiceConnect) String() string { return proto.CompactTextString(m) }
func (*ServiceConnect) ProtoMessage()    {}
func (*ServiceConnect) Descriptor() ([]byte, []int) {
	return fileDescriptor_structs_90c2cf680e97d80b, []int{14}
}
func (m *ServiceConnect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceConnect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceConnect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ServiceConnect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceConnect.Merge(dst, src)
}
func (m *ServiceConnect) XXX_Size() int {
	return m.Size()
}
func (m *ServiceConnect) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceConnect.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceConnect proto.InternalMessageInfo

// CheckServiceNode is used to provide the node, its service
// definition, as well as a HealthCheck that is associated.
type CheckServiceNode struct {
	Node    *Node          `protobuf:"bytes,1,opt,name=Node" json:""`
	Service *NodeService   `protobuf:"bytes,2,opt,name=Service" json:""`
	Checks  []*HealthCheck `protobuf:"bytes,3,rep,name=Checks" json:""`
}

func (m *CheckServiceNode) Reset()         { *m = CheckServiceNode{} }
func (m *CheckServiceNode) String() string { return proto.CompactTextString(m) }
func (*CheckServiceNode) ProtoMessage()    {}
func (*CheckServiceNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_structs_90c2cf680e97d80b, []int{15}
}
func (m *CheckServiceNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckServiceNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckServiceNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CheckServiceNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckServiceNode.Merge(dst, src)
}
func (m *CheckServiceNode) XXX_Size() int {
	return m.Size()
}
func (m *CheckServiceNode) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckServiceNode.DiscardUnknown(m)
}

var xxx_messageInfo_CheckServiceNode proto.InternalMessageInfo

// NodeService is a service provided by a node
type NodeService struct {
	// Kind is the kind of service this is. Different kinds of services may
	// have differing validation, DNS behavior, etc. An empty kind will default
	// to the Default kind. See ServiceKind for the full list of kinds.
	Kind              ServiceKind       `protobuf:"bytes,1,opt,name=Kind,proto3,casttype=ServiceKind" json:",omitempty"`
	ID                string            `protobuf:"bytes,2,opt,name=ID,proto3" json:""`
	Service           string            `protobuf:"bytes,3,opt,name=Service,proto3" json:""`
	Tags              []string          `protobuf:"bytes,4,rep,name=Tags" json:""`
	Address           string            `protobuf:"bytes,5,opt,name=Address,proto3" json:""`
	Meta              map[string]string `protobuf:"bytes,6,rep,name=Meta" json:"" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Port              int               `protobuf:"varint,7,opt,name=Port,proto3,casttype=int" json:""`
	Weights           *Weights          `protobuf:"bytes,8,opt,name=Weights" json:""`
	EnableTagOverride bool              `protobuf:"varint,9,opt,name=EnableTagOverride,proto3" json:""`
	// ProxyDestination is DEPRECATED in favor of Proxy.DestinationServiceName.
	// It's retained since this struct is used to parse input for
	// /catalog/register but nothing else internal should use it - once
	// request/config definitions are passes all internal uses of NodeService
	// should have this empty and use the Proxy.DestinationServiceNames field
	// below.
	//
	// It used to store the name of the service that this service is a Connect
	// proxy for. This is only valid if Kind is "connect-proxy". The destination
	// may be a service that isn't present in the catalog. This is expected and
	// allowed to allow for proxies to come up earlier than their target services.
	// DEPRECATED (ProxyDestination) - remove this when removing ProxyDestination
	ProxyDestination string `protobuf:"bytes,10,opt,name=ProxyDestination,proto3" json:"" bexpr:"-"`
	// Proxy is the configuration set for Kind = connect-proxy. It is mandatory in
	// that case and an error to be set for any other kind. This config is part of
	// a proxy service definition and is distinct from but shares some fields with
	// the Connect.Proxy which configures a managed proxy as part of the actual
	// service's definition. This duplication is ugly but seemed better than the
	// alternative which was to re-use the same struct fields for both cases even
	// though the semantics are different and the non-shred fields make no sense
	// in the other case. ProxyConfig may be a more natural name here, but it's
	// confusing for the UX because one of the fields in ConnectProxyConfig is
	// also called just "Config"
	Proxy ConnectProxyConfig `protobuf:"bytes,11,opt,name=Proxy" json:"Proxy"`
	// Connect are the Connect settings for a service. This is purposely NOT
	// a pointer so that we never have to nil-check this.
	Connect ServiceConnect `protobuf:"bytes,12,opt,name=Connect" json:"Connect"`
	// LocallyRegisteredAsSidecar is private as it is only used by a local agent
	// state to track if the service was registered from a nested sidecar_service
	// block. We need to track that so we can know whether we need to deregister
	// it automatically too if it's removed from the service definition or if the
	// parent service is deregistered. Relying only on ID would cause us to
	// deregister regular services if they happen to be registered using the same
	// ID scheme as our sidecars do by default. We could use meta but that gets
	// unpleasant because we can't use the consul- prefix from an agent (reserved
	// for use internally but in practice that means within the state store or in
	// responses only), and it leaks the detail publicly which people might rely
	// on which is a bit unpleasant for something that is meant to be config-file
	// syntax sugar. Note this is not translated to ServiceNode and friends and
	// may not be set on a NodeService that isn't the one the agent registered and
	// keeps in it's local state. We never want this rendered in JSON as it's
	// internal only. Right now our agent endpoints return api structs which don't
	// include it but this is a safety net incase we change that or there is
	// somewhere this is used in API output.
	LocallyRegisteredAsSidecar bool `protobuf:"varint,13,opt,name=LocallyRegisteredAsSidecar,proto3" json:"-" bexpr:"-"`
	RaftIndex                  `protobuf:"bytes,14,opt,name=RaftIndex,embedded=RaftIndex" json:"" bexpr:"-"`
}

func (m *NodeService) Reset()         { *m = NodeService{} }
func (m *NodeService) String() string { return proto.CompactTextString(m) }
func (*NodeService) ProtoMessage()    {}
func (*NodeService) Descriptor() ([]byte, []int) {
	return fileDescriptor_structs_90c2cf680e97d80b, []int{16}
}
func (m *NodeService) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeService) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeService.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NodeService) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeService.Merge(dst, src)
}
func (m *NodeService) XXX_Size() int {
	return m.Size()
}
func (m *NodeService) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeService.DiscardUnknown(m)
}

var xxx_messageInfo_NodeService proto.InternalMessageInfo

type IndexedCheckServiceNodes struct {
	Nodes     []CheckServiceNode `protobuf:"bytes,1,rep,name=Nodes" json:"Nodes"`
	QueryMeta `protobuf:"bytes,2,opt,name=QueryMeta,embedded=QueryMeta" json:"QueryMeta"`
}

func (m *IndexedCheckServiceNodes) Reset()         { *m = IndexedCheckServiceNodes{} }
func (m *IndexedCheckServiceNodes) String() string { return proto.CompactTextString(m) }
func (*IndexedCheckServiceNodes) ProtoMessage()    {}
func (*IndexedCheckServiceNodes) Descriptor() ([]byte, []int) {
	return fileDescriptor_structs_90c2cf680e97d80b, []int{17}
}
func (m *IndexedCheckServiceNodes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexedCheckServiceNodes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexedCheckServiceNodes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IndexedCheckServiceNodes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexedCheckServiceNodes.Merge(dst, src)
}
func (m *IndexedCheckServiceNodes) XXX_Size() int {
	return m.Size()
}
func (m *IndexedCheckServiceNodes) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexedCheckServiceNodes.DiscardUnknown(m)
}

var xxx_messageInfo_IndexedCheckServiceNodes proto.InternalMessageInfo

type ProtoHeaders struct {
	Headers map[string]*StringList `protobuf:"bytes,1,rep,name=Headers" json:"Headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ProtoHeaders) Reset()         { *m = ProtoHeaders{} }
func (m *ProtoHeaders) String() string { return proto.CompactTextString(m) }
func (*ProtoHeaders) ProtoMessage()    {}
func (*ProtoHeaders) Descriptor() ([]byte, []int) {
	return fileDescriptor_structs_90c2cf680e97d80b, []int{18}
}
func (m *ProtoHeaders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtoHeaders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtoHeaders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ProtoHeaders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoHeaders.Merge(dst, src)
}
func (m *ProtoHeaders) XXX_Size() int {
	return m.Size()
}
func (m *ProtoHeaders) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoHeaders.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoHeaders proto.InternalMessageInfo

type StringList struct {
	Values []string `protobuf:"bytes,1,rep,name=Values" json:"Values,omitempty"`
}

func (m *StringList) Reset()         { *m = StringList{} }
func (m *StringList) String() string { return proto.CompactTextString(m) }
func (*StringList) ProtoMessage()    {}
func (*StringList) Descriptor() ([]byte, []int) {
	return fileDescriptor_structs_90c2cf680e97d80b, []int{19}
}
func (m *StringList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StringList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringList.Merge(dst, src)
}
func (m *StringList) XXX_Size() int {
	return m.Size()
}
func (m *StringList) XXX_DiscardUnknown() {
	xxx_messageInfo_StringList.DiscardUnknown(m)
}

var xxx_messageInfo_StringList proto.InternalMessageInfo

func init() {
	proto.RegisterType((*QueryMeta)(nil), "structs.QueryMeta")
	proto.RegisterType((*QueryOptions)(nil), "structs.QueryOptions")
	proto.RegisterType((*QuerySource)(nil), "structs.QuerySource")
	proto.RegisterType((*ServiceSpecificRequest)(nil), "structs.ServiceSpecificRequest")
	proto.RegisterMapType((map[string]string)(nil), "structs.ServiceSpecificRequest.NodeMetaFiltersEntry")
	proto.RegisterType((*RaftIndex)(nil), "structs.RaftIndex")
	proto.RegisterType((*Node)(nil), "structs.Node")
	proto.RegisterMapType((map[string]string)(nil), "structs.Node.MetaEntry")
	proto.RegisterMapType((map[string]string)(nil), "structs.Node.TaggedAddressesEntry")
	proto.RegisterType((*Weights)(nil), "structs.Weights")
	proto.RegisterType((*CheckType)(nil), "structs.CheckType")
	proto.RegisterType((*ServiceDefinition)(nil), "structs.ServiceDefinition")
	proto.RegisterMapType((map[string]string)(nil), "structs.ServiceDefinition.MetaEntry")
	proto.RegisterType((*HealthCheckDefinition)(nil), "structs.HealthCheckDefinition")
	proto.RegisterType((*HealthCheck)(nil), "structs.HealthCheck")
	proto.RegisterType((*Upstream)(nil), "structs.Upstream")
	proto.RegisterType((*ConnectProxyConfig)(nil), "structs.ConnectProxyConfig")
	proto.RegisterType((*ServiceDefinitionConnectProxy)(nil), "structs.ServiceDefinitionConnectProxy")
	proto.RegisterType((*ServiceConnect)(nil), "structs.ServiceConnect")
	proto.RegisterType((*CheckServiceNode)(nil), "structs.CheckServiceNode")
	proto.RegisterType((*NodeService)(nil), "structs.NodeService")
	proto.RegisterMapType((map[string]string)(nil), "structs.NodeService.MetaEntry")
	proto.RegisterType((*IndexedCheckServiceNodes)(nil), "structs.IndexedCheckServiceNodes")
	proto.RegisterType((*ProtoHeaders)(nil), "structs.ProtoHeaders")
	proto.RegisterMapType((map[string]*StringList)(nil), "structs.ProtoHeaders.HeadersEntry")
	proto.RegisterType((*StringList)(nil), "structs.StringList")
}
func (m *QueryMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Index))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.LastContact)))
	n1, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.LastContact, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.KnownLeader {
		dAtA[i] = 0x18
		i++
		if m.KnownLeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ConsistencyLevel) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ConsistencyLevel)))
		i += copy(dAtA[i:], m.ConsistencyLevel)
	}
	return i, nil
}

func (m *QueryOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if m.MinQueryIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.MinQueryIndex))
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.MaxQueryTime)))
	n2, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.MaxQueryTime, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if m.AllowStale {
		dAtA[i] = 0x20
		i++
		if m.AllowStale {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RequireConsistent {
		dAtA[i] = 0x28
		i++
		if m.RequireConsistent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UseCache {
		dAtA[i] = 0x30
		i++
		if m.UseCache {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.MaxStaleDuration)))
	n3, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.MaxStaleDuration, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x42
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.MaxAge)))
	n4, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.MaxAge, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.MustRevalidate {
		dAtA[i] = 0x48
		i++
		if m.MustRevalidate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0x52
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.StaleIfError)))
	n5, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.StaleIfError, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if len(m.Filter) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Filter)))
		i += copy(dAtA[i:], m.Filter)
	}
	return i, nil
}

func (m *QuerySource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Datacenter) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Datacenter)))
		i += copy(dAtA[i:], m.Datacenter)
	}
	if len(m.Segment) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Segment)))
		i += copy(dAtA[i:], m.Segment)
	}
	if len(m.Node) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Node)))
		i += copy(dAtA[i:], m.Node)
	}
	if len(m.Ip) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	return i, nil
}

func (m *ServiceSpecificRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceSpecificRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Datacenter) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Datacenter)))
		i += copy(dAtA[i:], m.Datacenter)
	}
	if len(m.NodeMetaFilters) > 0 {
		for k, _ := range m.NodeMetaFilters {
			dAtA[i] = 0x12
			i++
			v := m.NodeMetaFilters[k]
			mapSize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			i = encodeVarintStructs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.ServiceName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ServiceName)))
		i += copy(dAtA[i:], m.ServiceName)
	}
	if len(m.ServiceTag) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ServiceTag)))
		i += copy(dAtA[i:], m.ServiceTag)
	}
	if len(m.ServiceTags) > 0 {
		for _, s := range m.ServiceTags {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ServiceAddress) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ServiceAddress)))
		i += copy(dAtA[i:], m.ServiceAddress)
	}
	if m.TagFilter {
		dAtA[i] = 0x38
		i++
		if m.TagFilter {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0x42
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.Source.Size()))
	n6, err := m.Source.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if m.Connect {
		dAtA[i] = 0x48
		i++
		if m.Connect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0x52
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.QueryOptions.Size()))
	n7, err := m.QueryOptions.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	return i, nil
}

func (m *RaftIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftIndex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CreateIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.CreateIndex))
	}
	if m.ModifyIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.ModifyIndex))
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Node) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Node)))
		i += copy(dAtA[i:], m.Node)
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.Datacenter) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Datacenter)))
		i += copy(dAtA[i:], m.Datacenter)
	}
	if len(m.TaggedAddresses) > 0 {
		for k, _ := range m.TaggedAddresses {
			dAtA[i] = 0x2a
			i++
			v := m.TaggedAddresses[k]
			mapSize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			i = encodeVarintStructs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Meta) > 0 {
		for k, _ := range m.Meta {
			dAtA[i] = 0x32
			i++
			v := m.Meta[k]
			mapSize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			i = encodeVarintStructs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.RaftIndex.Size()))
	n8, err := m.RaftIndex.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	return i, nil
}

func (m *Weights) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Weights) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Passing != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Passing))
	}
	if m.Warning != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Warning))
	}
	return i, nil
}

func (m *CheckType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CheckID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.CheckID)))
		i += copy(dAtA[i:], m.CheckID)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.Notes) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Notes)))
		i += copy(dAtA[i:], m.Notes)
	}
	if len(m.ScriptArgs) > 0 {
		for _, s := range m.ScriptArgs {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.HTTP) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.HTTP)))
		i += copy(dAtA[i:], m.HTTP)
	}
	if len(m.Method) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Method)))
		i += copy(dAtA[i:], m.Method)
	}
	if len(m.TCP) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.TCP)))
		i += copy(dAtA[i:], m.TCP)
	}
	dAtA[i] = 0x4a
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.Interval)))
	n9, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Interval, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if len(m.AliasNode) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.AliasNode)))
		i += copy(dAtA[i:], m.AliasNode)
	}
	if len(m.AliasService) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.AliasService)))
		i += copy(dAtA[i:], m.AliasService)
	}
	if len(m.DockerContainerID) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.DockerContainerID)))
		i += copy(dAtA[i:], m.DockerContainerID)
	}
	if len(m.Shell) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Shell)))
		i += copy(dAtA[i:], m.Shell)
	}
	if len(m.GRPC) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.GRPC)))
		i += copy(dAtA[i:], m.GRPC)
	}
	if m.GRPCUseTLS {
		dAtA[i] = 0x78
		i++
		if m.GRPCUseTLS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TLSSkipVerify {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.TLSSkipVerify {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0x8a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.Timeout)))
	n10, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Timeout, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x92
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.TTL)))
	n11, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.TTL, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x9a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.DeregisterCriticalServiceAfter)))
	n12, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.DeregisterCriticalServiceAfter, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0xa2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.Header.Size()))
	n13, err := m.Header.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	return i, nil
}

func (m *ServiceDefinition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceDefinition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.ID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.Meta) > 0 {
		for k, _ := range m.Meta {
			dAtA[i] = 0x32
			i++
			v := m.Meta[k]
			mapSize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			i = encodeVarintStructs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Port != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Port))
	}
	dAtA[i] = 0x42
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.Check.Size()))
	n14, err := m.Check.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	if len(m.Checks) > 0 {
		for _, msg := range m.Checks {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintStructs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Weights != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Weights.Size()))
		n15, err := m.Weights.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if m.EnableTagOverride {
		dAtA[i] = 0x60
		i++
		if m.EnableTagOverride {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ProxyDestination) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ProxyDestination)))
		i += copy(dAtA[i:], m.ProxyDestination)
	}
	if m.Proxy != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Proxy.Size()))
		n16, err := m.Proxy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Connect != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Connect.Size()))
		n17, err := m.Connect.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *HealthCheckDefinition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheckDefinition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HTTP) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.HTTP)))
		i += copy(dAtA[i:], m.HTTP)
	}
	if m.TLSSkipVerify {
		dAtA[i] = 0x10
		i++
		if m.TLSSkipVerify {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.Header.Size()))
	n18, err := m.Header.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	if len(m.Method) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Method)))
		i += copy(dAtA[i:], m.Method)
	}
	if len(m.TCP) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.TCP)))
		i += copy(dAtA[i:], m.TCP)
	}
	dAtA[i] = 0x32
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.Interval)))
	n19, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Interval, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	dAtA[i] = 0x3a
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.Timeout)))
	n20, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Timeout, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	dAtA[i] = 0x42
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.DeregisterCriticalServiceAfter)))
	n21, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.DeregisterCriticalServiceAfter, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	return i, nil
}

func (m *HealthCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Node) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Node)))
		i += copy(dAtA[i:], m.Node)
	}
	if len(m.CheckID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.CheckID)))
		i += copy(dAtA[i:], m.CheckID)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.Notes) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Notes)))
		i += copy(dAtA[i:], m.Notes)
	}
	if len(m.Output) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Output)))
		i += copy(dAtA[i:], m.Output)
	}
	if len(m.ServiceID) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ServiceID)))
		i += copy(dAtA[i:], m.ServiceID)
	}
	if len(m.ServiceName) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ServiceName)))
		i += copy(dAtA[i:], m.ServiceName)
	}
	if len(m.ServiceTags) > 0 {
		for _, s := range m.ServiceTags {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x52
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.Definition.Size()))
	n22, err := m.Definition.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	dAtA[i] = 0x5a
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.RaftIndex.Size()))
	n23, err := m.RaftIndex.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	return i, nil
}

func (m *Upstream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Upstream) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DestinationType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.DestinationType)))
		i += copy(dAtA[i:], m.DestinationType)
	}
	if len(m.DestinationNamespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.DestinationNamespace)))
		i += copy(dAtA[i:], m.DestinationNamespace)
	}
	if len(m.DestinationName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.DestinationName)))
		i += copy(dAtA[i:], m.DestinationName)
	}
	if len(m.Datacenter) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Datacenter)))
		i += copy(dAtA[i:], m.Datacenter)
	}
	if len(m.LocalBindAddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.LocalBindAddress)))
		i += copy(dAtA[i:], m.LocalBindAddress)
	}
	if m.LocalBindPort != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.LocalBindPort))
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.Config.Size()))
	n24, err := m.Config.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n24
	return i, nil
}

func (m *ConnectProxyConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectProxyConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DestinationServiceName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.DestinationServiceName)))
		i += copy(dAtA[i:], m.DestinationServiceName)
	}
	if len(m.DestinationServiceID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.DestinationServiceID)))
		i += copy(dAtA[i:], m.DestinationServiceID)
	}
	if len(m.LocalServiceAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.LocalServiceAddress)))
		i += copy(dAtA[i:], m.LocalServiceAddress)
	}
	if m.LocalServicePort != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.LocalServicePort))
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.Config.Size()))
	n25, err := m.Config.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n25
	if len(m.Upstreams) > 0 {
		for _, msg := range m.Upstreams {
			dAtA[i] = 0x32
			i++
			i = encodeVarintStructs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ServiceDefinitionConnectProxy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceDefinitionConnectProxy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ExecMode) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ExecMode)))
		i += copy(dAtA[i:], m.ExecMode)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.Config.Size()))
	n26, err := m.Config.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n26
	if len(m.Upstreams) > 0 {
		for _, msg := range m.Upstreams {
			dAtA[i] = 0x22
			i++
			i = encodeVarintStructs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ServiceConnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceConnect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Native {
		dAtA[i] = 0x8
		i++
		if m.Native {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Proxy != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Proxy.Size()))
		n27, err := m.Proxy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.SidecarService != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.SidecarService.Size()))
		n28, err := m.SidecarService.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *CheckServiceNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckServiceNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Node != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Node.Size()))
		n29, err := m.Node.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.Service != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Service.Size()))
		n30, err := m.Service.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if len(m.Checks) > 0 {
		for _, msg := range m.Checks {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintStructs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NodeService) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeService) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.ID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Service) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Service)))
		i += copy(dAtA[i:], m.Service)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.Meta) > 0 {
		for k, _ := range m.Meta {
			dAtA[i] = 0x32
			i++
			v := m.Meta[k]
			mapSize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			i = encodeVarintStructs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Port != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Port))
	}
	if m.Weights != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Weights.Size()))
		n31, err := m.Weights.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.EnableTagOverride {
		dAtA[i] = 0x48
		i++
		if m.EnableTagOverride {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ProxyDestination) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ProxyDestination)))
		i += copy(dAtA[i:], m.ProxyDestination)
	}
	dAtA[i] = 0x5a
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.Proxy.Size()))
	n32, err := m.Proxy.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n32
	dAtA[i] = 0x62
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.Connect.Size()))
	n33, err := m.Connect.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n33
	if m.LocallyRegisteredAsSidecar {
		dAtA[i] = 0x68
		i++
		if m.LocallyRegisteredAsSidecar {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0x72
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.RaftIndex.Size()))
	n34, err := m.RaftIndex.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n34
	return i, nil
}

func (m *IndexedCheckServiceNodes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexedCheckServiceNodes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStructs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintStructs(dAtA, i, uint64(m.QueryMeta.Size()))
	n35, err := m.QueryMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n35
	return i, nil
}

func (m *ProtoHeaders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtoHeaders) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for k, _ := range m.Headers {
			dAtA[i] = 0xa
			i++
			v := m.Headers[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovStructs(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovStructs(uint64(len(k))) + msgSize
			i = encodeVarintStructs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintStructs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintStructs(dAtA, i, uint64(v.Size()))
				n36, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n36
			}
		}
	}
	return i, nil
}

func (m *StringList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintStructs(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *QueryMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovStructs(uint64(m.Index))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.LastContact)
	n += 1 + l + sovStructs(uint64(l))
	if m.KnownLeader {
		n += 2
	}
	l = len(m.ConsistencyLevel)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	return n
}

func (m *QueryOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.MinQueryIndex != 0 {
		n += 1 + sovStructs(uint64(m.MinQueryIndex))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.MaxQueryTime)
	n += 1 + l + sovStructs(uint64(l))
	if m.AllowStale {
		n += 2
	}
	if m.RequireConsistent {
		n += 2
	}
	if m.UseCache {
		n += 2
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.MaxStaleDuration)
	n += 1 + l + sovStructs(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.MaxAge)
	n += 1 + l + sovStructs(uint64(l))
	if m.MustRevalidate {
		n += 2
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.StaleIfError)
	n += 1 + l + sovStructs(uint64(l))
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	return n
}

func (m *QuerySource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Datacenter)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Segment)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	return n
}

func (m *ServiceSpecificRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Datacenter)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.NodeMetaFilters) > 0 {
		for k, v := range m.NodeMetaFilters {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			n += mapEntrySize + 1 + sovStructs(uint64(mapEntrySize))
		}
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.ServiceTag)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.ServiceTags) > 0 {
		for _, s := range m.ServiceTags {
			l = len(s)
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	l = len(m.ServiceAddress)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.TagFilter {
		n += 2
	}
	l = m.Source.Size()
	n += 1 + l + sovStructs(uint64(l))
	if m.Connect {
		n += 2
	}
	l = m.QueryOptions.Size()
	n += 1 + l + sovStructs(uint64(l))
	return n
}

func (m *RaftIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateIndex != 0 {
		n += 1 + sovStructs(uint64(m.CreateIndex))
	}
	if m.ModifyIndex != 0 {
		n += 1 + sovStructs(uint64(m.ModifyIndex))
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Datacenter)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.TaggedAddresses) > 0 {
		for k, v := range m.TaggedAddresses {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			n += mapEntrySize + 1 + sovStructs(uint64(mapEntrySize))
		}
	}
	if len(m.Meta) > 0 {
		for k, v := range m.Meta {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			n += mapEntrySize + 1 + sovStructs(uint64(mapEntrySize))
		}
	}
	l = m.RaftIndex.Size()
	n += 1 + l + sovStructs(uint64(l))
	return n
}

func (m *Weights) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Passing != 0 {
		n += 1 + sovStructs(uint64(m.Passing))
	}
	if m.Warning != 0 {
		n += 1 + sovStructs(uint64(m.Warning))
	}
	return n
}

func (m *CheckType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CheckID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.ScriptArgs) > 0 {
		for _, s := range m.ScriptArgs {
			l = len(s)
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	l = len(m.HTTP)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.TCP)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Interval)
	n += 1 + l + sovStructs(uint64(l))
	l = len(m.AliasNode)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.AliasService)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.DockerContainerID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Shell)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.GRPC)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.GRPCUseTLS {
		n += 2
	}
	if m.TLSSkipVerify {
		n += 3
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Timeout)
	n += 2 + l + sovStructs(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.TTL)
	n += 2 + l + sovStructs(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.DeregisterCriticalServiceAfter)
	n += 2 + l + sovStructs(uint64(l))
	l = m.Header.Size()
	n += 2 + l + sovStructs(uint64(l))
	return n
}

func (m *ServiceDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.Meta) > 0 {
		for k, v := range m.Meta {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			n += mapEntrySize + 1 + sovStructs(uint64(mapEntrySize))
		}
	}
	if m.Port != 0 {
		n += 1 + sovStructs(uint64(m.Port))
	}
	l = m.Check.Size()
	n += 1 + l + sovStructs(uint64(l))
	if len(m.Checks) > 0 {
		for _, e := range m.Checks {
			l = e.Size()
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	if m.Weights != nil {
		l = m.Weights.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.EnableTagOverride {
		n += 2
	}
	l = len(m.ProxyDestination)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.Proxy != nil {
		l = m.Proxy.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.Connect != nil {
		l = m.Connect.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	return n
}

func (m *HealthCheckDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HTTP)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.TLSSkipVerify {
		n += 2
	}
	l = m.Header.Size()
	n += 1 + l + sovStructs(uint64(l))
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.TCP)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Interval)
	n += 1 + l + sovStructs(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Timeout)
	n += 1 + l + sovStructs(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.DeregisterCriticalServiceAfter)
	n += 1 + l + sovStructs(uint64(l))
	return n
}

func (m *HealthCheck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.CheckID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Output)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.ServiceID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.ServiceTags) > 0 {
		for _, s := range m.ServiceTags {
			l = len(s)
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	l = m.Definition.Size()
	n += 1 + l + sovStructs(uint64(l))
	l = m.RaftIndex.Size()
	n += 1 + l + sovStructs(uint64(l))
	return n
}

func (m *Upstream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DestinationType)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.DestinationNamespace)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.DestinationName)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Datacenter)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.LocalBindAddress)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.LocalBindPort != 0 {
		n += 1 + sovStructs(uint64(m.LocalBindPort))
	}
	l = m.Config.Size()
	n += 1 + l + sovStructs(uint64(l))
	return n
}

func (m *ConnectProxyConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DestinationServiceName)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.DestinationServiceID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.LocalServiceAddress)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.LocalServicePort != 0 {
		n += 1 + sovStructs(uint64(m.LocalServicePort))
	}
	l = m.Config.Size()
	n += 1 + l + sovStructs(uint64(l))
	if len(m.Upstreams) > 0 {
		for _, e := range m.Upstreams {
			l = e.Size()
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	return n
}

func (m *ServiceDefinitionConnectProxy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	l = len(m.ExecMode)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = m.Config.Size()
	n += 1 + l + sovStructs(uint64(l))
	if len(m.Upstreams) > 0 {
		for _, e := range m.Upstreams {
			l = e.Size()
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	return n
}

func (m *ServiceConnect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Native {
		n += 2
	}
	if m.Proxy != nil {
		l = m.Proxy.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.SidecarService != nil {
		l = m.SidecarService.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	return n
}

func (m *CheckServiceNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.Checks) > 0 {
		for _, e := range m.Checks {
			l = e.Size()
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	return n
}

func (m *NodeService) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if len(m.Meta) > 0 {
		for k, v := range m.Meta {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + 1 + len(v) + sovStructs(uint64(len(v)))
			n += mapEntrySize + 1 + sovStructs(uint64(mapEntrySize))
		}
	}
	if m.Port != 0 {
		n += 1 + sovStructs(uint64(m.Port))
	}
	if m.Weights != nil {
		l = m.Weights.Size()
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.EnableTagOverride {
		n += 2
	}
	l = len(m.ProxyDestination)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	l = m.Proxy.Size()
	n += 1 + l + sovStructs(uint64(l))
	l = m.Connect.Size()
	n += 1 + l + sovStructs(uint64(l))
	if m.LocallyRegisteredAsSidecar {
		n += 2
	}
	l = m.RaftIndex.Size()
	n += 1 + l + sovStructs(uint64(l))
	return n
}

func (m *IndexedCheckServiceNodes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	l = m.QueryMeta.Size()
	n += 1 + l + sovStructs(uint64(l))
	return n
}

func (m *ProtoHeaders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for k, v := range m.Headers {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovStructs(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovStructs(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovStructs(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *StringList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovStructs(uint64(l))
		}
	}
	return n
}

func sovStructs(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStructs(x uint64) (n int) {
	return sovStructs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QueryMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastContact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.LastContact, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KnownLeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KnownLeader = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsistencyLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsistencyLevel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQueryIndex", wireType)
			}
			m.MinQueryIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinQueryIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQueryTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.MaxQueryTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowStale", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowStale = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireConsistent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireConsistent = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseCache", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseCache = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxStaleDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.MaxStaleDuration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.MaxAge, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustRevalidate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustRevalidate = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaleIfError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.StaleIfError, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datacenter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datacenter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Segment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceSpecificRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceSpecificRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceSpecificRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datacenter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datacenter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeMetaFilters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeMetaFilters == nil {
				m.NodeMetaFilters = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeMetaFilters[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceTags = append(m.ServiceTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagFilter", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TagFilter = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Connect = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.QueryOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateIndex", wireType)
			}
			m.CreateIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifyIndex", wireType)
			}
			m.ModifyIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModifyIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = github_com_hashicorp_consul_types.NodeID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datacenter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datacenter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaggedAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TaggedAddresses == nil {
				m.TaggedAddresses = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TaggedAddresses[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Meta[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RaftIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Weights) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Weights: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Weights: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passing", wireType)
			}
			m.Passing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Passing |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warning", wireType)
			}
			m.Warning = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Warning |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckID = github_com_hashicorp_consul_types.CheckID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptArgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScriptArgs = append(m.ScriptArgs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTTP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TCP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Interval, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasNode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliasNode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasService", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliasService = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DockerContainerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DockerContainerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shell", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shell = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GRPC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GRPC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GRPCUseTLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GRPCUseTLS = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSSkipVerify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TLSSkipVerify = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Timeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.TTL, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeregisterCriticalServiceAfter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.DeregisterCriticalServiceAfter, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = ServiceKind(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Meta[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Check", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Check.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checks = append(m.Checks, &CheckType{})
			if err := m.Checks[len(m.Checks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Weights == nil {
				m.Weights = &Weights{}
			}
			if err := m.Weights.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableTagOverride", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableTagOverride = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyDestination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyDestination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proxy == nil {
				m.Proxy = &ConnectProxyConfig{}
			}
			if err := m.Proxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connect == nil {
				m.Connect = &ServiceConnect{}
			}
			if err := m.Connect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheckDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheckDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheckDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTTP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSSkipVerify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TLSSkipVerify = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TCP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Interval, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Timeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeregisterCriticalServiceAfter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.DeregisterCriticalServiceAfter, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckID = github_com_hashicorp_consul_types.CheckID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceTags = append(m.ServiceTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Definition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RaftIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Upstream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Upstream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Upstream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datacenter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datacenter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalBindAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalBindAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalBindPort", wireType)
			}
			m.LocalBindPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalBindPort |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectProxyConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectProxyConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectProxyConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationServiceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationServiceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalServiceAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalServiceAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalServicePort", wireType)
			}
			m.LocalServicePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalServicePort |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upstreams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Upstreams = append(m.Upstreams, Upstream{})
			if err := m.Upstreams[len(m.Upstreams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceDefinitionConnectProxy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceDefinitionConnectProxy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceDefinitionConnectProxy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upstreams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Upstreams = append(m.Upstreams, Upstream{})
			if err := m.Upstreams[len(m.Upstreams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceConnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceConnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceConnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Native", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Native = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proxy == nil {
				m.Proxy = &ServiceDefinitionConnectProxy{}
			}
			if err := m.Proxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SidecarService", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SidecarService == nil {
				m.SidecarService = &ServiceDefinition{}
			}
			if err := m.SidecarService.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckServiceNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckServiceNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckServiceNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &Node{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &NodeService{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checks = append(m.Checks, &HealthCheck{})
			if err := m.Checks[len(m.Checks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeService) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeService: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeService: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = ServiceKind(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Meta[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Weights == nil {
				m.Weights = &Weights{}
			}
			if err := m.Weights.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableTagOverride", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableTagOverride = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyDestination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyDestination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Proxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Connect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocallyRegisteredAsSidecar", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocallyRegisteredAsSidecar = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RaftIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexedCheckServiceNodes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexedCheckServiceNodes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexedCheckServiceNodes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, CheckServiceNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.QueryMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtoHeaders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtoHeaders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtoHeaders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = make(map[string]*StringList)
			}
			var mapkey string
			var mapvalue *StringList
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStructs
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthStructs
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &StringList{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStructs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Headers[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStructs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStructs
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStructs(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStructs = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStructs   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("structs.proto", fileDescriptor_structs_90c2cf680e97d80b) }

var fileDescriptor_structs_90c2cf680e97d80b = []byte{
	// 2377 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x59, 0xcd, 0x73, 0x1b, 0x49,
	0xd9, 0xb7, 0xbe, 0xa5, 0x47, 0xfe, 0xec, 0x38, 0xde, 0x59, 0x6f, 0x22, 0xa9, 0xe6, 0xcd, 0x6b,
	0xbc, 0x26, 0xb1, 0x13, 0x6f, 0x96, 0x84, 0x00, 0x55, 0x58, 0x52, 0xd8, 0xa8, 0x6c, 0x25, 0xde,
	0x91, 0xb2, 0xb9, 0x51, 0x35, 0x19, 0xb5, 0xe5, 0x29, 0xcb, 0x33, 0x62, 0xa6, 0xe5, 0xb5, 0x6e,
	0x5c, 0x39, 0x6c, 0x15, 0x07, 0x0e, 0xe1, 0x40, 0x15, 0x17, 0xfe, 0x97, 0x1c, 0x38, 0xe4, 0x48,
	0x51, 0x94, 0x81, 0xe4, 0x96, 0x23, 0x70, 0x80, 0x2d, 0x8a, 0xa2, 0xfa, 0x6b, 0xa6, 0xe7, 0x23,
	0xf1, 0xda, 0xcb, 0xc9, 0xea, 0xe7, 0x6b, 0xba, 0x9f, 0x7e, 0xfa, 0xf7, 0xfc, 0xba, 0x0d, 0x73,
	0x3e, 0xf1, 0x26, 0x16, 0xf1, 0x37, 0xc7, 0x9e, 0x4b, 0x5c, 0x54, 0x12, 0xc3, 0xd5, 0xda, 0xd0,
	0x75, 0x87, 0x23, 0xbc, 0xc5, 0xc4, 0xcf, 0x27, 0x07, 0x5b, 0x83, 0x89, 0x67, 0x12, 0xdb, 0x75,
	0xb8, 0xe1, 0xea, 0xad, 0xa1, 0x4d, 0x0e, 0x27, 0xcf, 0x37, 0x2d, 0xf7, 0x78, 0x6b, 0xe8, 0x0e,
	0xdd, 0xd0, 0x90, 0x8e, 0xd8, 0x80, 0xfd, 0xe2, 0xe6, 0xfa, 0xef, 0x33, 0x50, 0xf9, 0x7c, 0x82,
	0xbd, 0x69, 0x17, 0x13, 0x13, 0xad, 0x42, 0xa1, 0xe3, 0x0c, 0xf0, 0xa9, 0x96, 0x69, 0x64, 0xd6,
	0xf3, 0xcd, 0xfc, 0xdb, 0xb3, 0xfa, 0x8c, 0xc1, 0x45, 0xa8, 0x03, 0xd5, 0x3d, 0xd3, 0x27, 0x2d,
	0xd7, 0x21, 0xa6, 0x45, 0xb4, 0x6c, 0x23, 0xb3, 0x5e, 0xdd, 0xfe, 0x70, 0x93, 0x4f, 0x67, 0x53,
	0x7e, 0x65, 0xb3, 0x2d, 0xa6, 0xd3, 0x9c, 0x7d, 0x79, 0x56, 0x9f, 0xa1, 0x01, 0x5e, 0xfc, 0xb9,
	0x9e, 0x31, 0x54, 0x5f, 0xb4, 0x06, 0xd5, 0x5d, 0xc7, 0xfd, 0xd2, 0xd9, 0xc3, 0xe6, 0x00, 0x7b,
	0x5a, 0xae, 0x91, 0x59, 0x2f, 0x8b, 0x8f, 0xa9, 0x0a, 0x74, 0x1b, 0x16, 0x5b, 0xae, 0xe3, 0xdb,
	0x3e, 0xc1, 0x8e, 0x35, 0xdd, 0xc3, 0x27, 0x78, 0xa4, 0xe5, 0x1b, 0x99, 0xf5, 0x8a, 0x30, 0x4e,
	0x68, 0xf5, 0x5f, 0xe5, 0x61, 0x96, 0x2d, 0xe7, 0xc9, 0x98, 0x4e, 0xc2, 0x47, 0xcb, 0x50, 0xe8,
	0xbb, 0x47, 0xd8, 0x61, 0x2b, 0xaa, 0x18, 0x7c, 0x80, 0x6e, 0xc0, 0x5c, 0xd7, 0x76, 0x98, 0x21,
	0x5f, 0x2f, 0x5d, 0x4d, 0xde, 0x88, 0x0a, 0xd1, 0x67, 0x30, 0xdb, 0x35, 0x4f, 0x99, 0xa0, 0x6f,
	0x1f, 0x63, 0x36, 0xcf, 0xf7, 0x2e, 0xb9, 0xfc, 0x52, 0x2e, 0x37, 0xe2, 0x88, 0x6a, 0x00, 0x3b,
	0xa3, 0x91, 0xfb, 0x65, 0x8f, 0x98, 0x23, 0xcc, 0x56, 0x50, 0x36, 0x14, 0x09, 0xba, 0x09, 0x4b,
	0x06, 0xfe, 0xd9, 0xc4, 0xf6, 0x70, 0xb0, 0x20, 0xa2, 0x15, 0x98, 0x59, 0x52, 0x81, 0x56, 0xa1,
	0xfc, 0xd4, 0xc7, 0x2d, 0xd3, 0x3a, 0xc4, 0x5a, 0x91, 0x19, 0x05, 0x63, 0xf4, 0x04, 0x16, 0xbb,
	0xe6, 0x29, 0x8b, 0x2a, 0x67, 0xa5, 0x95, 0xbe, 0xf9, 0xb4, 0x13, 0xce, 0xe8, 0x07, 0x50, 0xec,
	0x9a, 0xa7, 0x3b, 0x43, 0xac, 0x95, 0xbf, 0x79, 0x18, 0xe1, 0x82, 0xd6, 0x60, 0xbe, 0x3b, 0xf1,
	0x89, 0x81, 0x4f, 0xcc, 0x91, 0x3d, 0x30, 0x09, 0xd6, 0x2a, 0x6c, 0xbe, 0x31, 0x29, 0x4d, 0x34,
	0xfb, 0x6a, 0xe7, 0xe0, 0xa1, 0xe7, 0xb9, 0x9e, 0x06, 0x17, 0x48, 0xb4, 0xea, 0x88, 0x56, 0xa0,
	0xf8, 0x13, 0x7b, 0x44, 0xb0, 0xa7, 0x55, 0xd9, 0x76, 0x8b, 0x91, 0x7e, 0x04, 0x55, 0xb6, 0x1b,
	0x3d, 0x77, 0xe2, 0x59, 0x6c, 0x3f, 0xda, 0x26, 0x31, 0x2d, 0xec, 0x50, 0x53, 0x5e, 0x19, 0x8a,
	0x04, 0x69, 0x50, 0xea, 0xe1, 0xe1, 0x31, 0xdd, 0x85, 0x2c, 0x53, 0xca, 0x21, 0x42, 0x90, 0x7f,
	0xec, 0x0e, 0x78, 0x29, 0x54, 0x0c, 0xf6, 0x1b, 0xcd, 0x43, 0xb6, 0x33, 0xe6, 0x75, 0x69, 0x64,
	0x3b, 0x63, 0xfd, 0xd7, 0x79, 0x58, 0xe9, 0x61, 0xef, 0xc4, 0xb6, 0x70, 0x6f, 0x8c, 0x2d, 0xfb,
	0xc0, 0xb6, 0xe8, 0x26, 0x62, 0x9f, 0x9c, 0xfb, 0xe1, 0x9f, 0xc2, 0x02, 0x0d, 0x49, 0xcf, 0x22,
	0x9f, 0xb9, 0xaf, 0x65, 0x1b, 0xb9, 0xf5, 0xea, 0xf6, 0xdd, 0x4d, 0x09, 0x07, 0xe9, 0x91, 0x37,
	0x63, 0x6e, 0x0f, 0x1d, 0xe2, 0x4d, 0x8d, 0x78, 0x30, 0xd4, 0x80, 0xaa, 0xf0, 0x7f, 0x6c, 0x1e,
	0xcb, 0x55, 0xa8, 0x22, 0x3a, 0x43, 0x31, 0xec, 0x9b, 0x43, 0xb1, 0x28, 0x45, 0xa2, 0x44, 0xe8,
	0x9b, 0x43, 0x5f, 0x2b, 0x34, 0x72, 0x4a, 0x04, 0x2a, 0xa2, 0x9b, 0x2e, 0x86, 0x3b, 0x83, 0x81,
	0x87, 0x7d, 0x9f, 0x15, 0x69, 0xc5, 0x88, 0x49, 0xd1, 0x35, 0xa8, 0xf4, 0xcd, 0xa1, 0xd8, 0xae,
	0x12, 0xab, 0x8b, 0x50, 0x80, 0xb6, 0xa1, 0xc8, 0x37, 0x4b, 0xd4, 0xdd, 0x72, 0x90, 0x00, 0x65,
	0x23, 0x9b, 0x79, 0x5a, 0x07, 0x86, 0xb0, 0xa4, 0xdb, 0xd6, 0x72, 0x1d, 0x07, 0x5b, 0x44, 0xd4,
	0x99, 0x1c, 0xa2, 0x56, 0x14, 0x15, 0x44, 0x81, 0x5d, 0x8d, 0xc6, 0x14, 0x4a, 0x5e, 0x5c, 0xaf,
	0xce, 0x68, 0x71, 0xa9, 0xf2, 0xd5, 0x26, 0x2c, 0xa7, 0x65, 0x19, 0x2d, 0x42, 0xee, 0x08, 0x4f,
	0xc5, 0x6e, 0xd2, 0x9f, 0x14, 0x74, 0x4e, 0xcc, 0xd1, 0x04, 0x8b, 0xea, 0xe1, 0x83, 0x07, 0xd9,
	0xfb, 0x19, 0xfd, 0x18, 0x2a, 0x86, 0x79, 0x40, 0x38, 0xbe, 0x6c, 0x41, 0xb5, 0xe5, 0x61, 0x93,
	0x60, 0x15, 0x73, 0xe7, 0xfe, 0x76, 0x56, 0xaf, 0x3c, 0xc7, 0xa7, 0x63, 0xef, 0x81, 0x7e, 0x4b,
	0x37, 0x54, 0x0b, 0xea, 0xd0, 0x75, 0x07, 0xf6, 0x81, 0x0a, 0x5a, 0x09, 0x07, 0xc5, 0x42, 0xff,
	0x57, 0x8e, 0xd7, 0x2b, 0xfa, 0x31, 0x64, 0x3b, 0x6d, 0x3e, 0xc5, 0xe6, 0x6d, 0x8a, 0x9d, 0x5f,
	0x9f, 0xd5, 0xd7, 0x95, 0x4e, 0x71, 0x68, 0xfa, 0x87, 0xb6, 0xe5, 0x7a, 0xe3, 0x2d, 0xcb, 0x75,
	0xfc, 0xc9, 0x68, 0x8b, 0x4c, 0xc7, 0xd8, 0x67, 0x55, 0xd5, 0x69, 0x1b, 0xd9, 0x4e, 0x1b, 0x69,
	0xa2, 0xf2, 0xb3, 0x0a, 0xfe, 0xf2, 0xd8, 0x35, 0x28, 0xc9, 0x9d, 0xce, 0x29, 0x4a, 0x29, 0x44,
	0x37, 0x22, 0x45, 0xaf, 0xe2, 0xb7, 0x5a, 0xfa, 0x06, 0x2c, 0xf4, 0xcd, 0xe1, 0x10, 0x0f, 0x84,
	0x1b, 0xe6, 0xc5, 0x55, 0xdd, 0xd6, 0x83, 0x5d, 0xa2, 0x5f, 0xdb, 0x8c, 0x19, 0xb1, 0x2d, 0x10,
	0xe1, 0xe2, 0x01, 0xd0, 0x1d, 0xc8, 0xd3, 0xdd, 0xd2, 0x8a, 0x2c, 0xd0, 0x07, 0xd1, 0x40, 0x54,
	0xa3, 0x7a, 0x33, 0x53, 0xb4, 0xab, 0x6c, 0x90, 0x40, 0x4e, 0x14, 0xf8, 0x05, 0x9a, 0xe6, 0x87,
	0xb2, 0x46, 0xa8, 0x6b, 0x74, 0x03, 0x42, 0x7f, 0x5a, 0x31, 0x69, 0xd3, 0xbd, 0x48, 0xc5, 0xac,
	0xde, 0x83, 0x4a, 0x30, 0xd3, 0x0b, 0x95, 0xda, 0x33, 0x28, 0x3d, 0xc3, 0xf6, 0xf0, 0x90, 0xf8,
	0xe8, 0xff, 0xa1, 0xb4, 0x6f, 0xfa, 0xbe, 0xed, 0x0c, 0x99, 0x6b, 0xa1, 0x59, 0x15, 0x25, 0x90,
	0xb3, 0x1d, 0x62, 0x48, 0x1d, 0x35, 0x7b, 0x66, 0x7a, 0x0e, 0x35, 0xcb, 0xa6, 0x98, 0x09, 0x9d,
	0xfe, 0x55, 0x09, 0x2a, 0xad, 0x43, 0x6c, 0x1d, 0xf5, 0xa7, 0x63, 0x8c, 0x76, 0xa1, 0xc4, 0x06,
	0x41, 0x79, 0xdd, 0x11, 0x4e, 0x1f, 0x9f, 0x5f, 0x5e, 0xc2, 0xd1, 0x90, 0x11, 0x58, 0x91, 0x51,
	0x60, 0x8a, 0x16, 0x19, 0xc5, 0xa5, 0x6b, 0x50, 0xec, 0x11, 0x93, 0x4c, 0xa2, 0x35, 0x26, 0x64,
	0x94, 0xb7, 0x3c, 0x76, 0x09, 0xf6, 0x23, 0xd5, 0xc5, 0x45, 0xb4, 0xfc, 0x7a, 0x96, 0x67, 0x8f,
	0xc9, 0x8e, 0x27, 0x01, 0x4b, 0x96, 0x5f, 0x28, 0xa7, 0x5f, 0x7e, 0xd4, 0xef, 0xef, 0x73, 0xac,
	0x92, 0x5f, 0xa6, 0x12, 0xfa, 0xe5, 0x2e, 0x26, 0x87, 0xee, 0x80, 0x95, 0x43, 0xf0, 0x65, 0x2e,
	0x43, 0x2b, 0x90, 0xeb, 0xb7, 0xf6, 0x19, 0x48, 0x49, 0x15, 0x15, 0xa0, 0x16, 0x94, 0x3b, 0xb4,
	0xae, 0x4f, 0xcc, 0x11, 0x03, 0xa3, 0x0b, 0x50, 0xa5, 0xc0, 0x11, 0xe9, 0x50, 0xd9, 0x19, 0xd9,
	0xa6, 0xcf, 0x0e, 0x1e, 0x28, 0x9f, 0x08, 0xc5, 0x68, 0x1d, 0x66, 0xd9, 0x40, 0xa0, 0x2b, 0x6f,
	0x7c, 0xc2, 0x2c, 0xa2, 0x41, 0xdb, 0xb0, 0xd4, 0x76, 0xad, 0x23, 0xec, 0x31, 0x1a, 0x66, 0x3b,
	0xd8, 0xeb, 0xb4, 0xb5, 0x59, 0xc5, 0x3c, 0xa9, 0xa6, 0x89, 0xed, 0x1d, 0xe2, 0xd1, 0x48, 0x9b,
	0x53, 0x13, 0xcb, 0x44, 0x34, 0x65, 0x9f, 0x19, 0xfb, 0x2d, 0x6d, 0x5e, 0x4d, 0x19, 0x95, 0xd0,
	0x94, 0xd3, 0xbf, 0x4f, 0x7d, 0xdc, 0xdf, 0xeb, 0x69, 0x0b, 0x0a, 0xbd, 0x53, 0xe4, 0x68, 0x03,
	0xe6, 0xfa, 0x7b, 0xbd, 0xde, 0x91, 0x3d, 0xfe, 0x02, 0x7b, 0xf6, 0xc1, 0x54, 0x5b, 0x54, 0x0c,
	0xa3, 0x2a, 0xb4, 0x03, 0x25, 0xca, 0xa4, 0xdc, 0x09, 0xd1, 0x96, 0x2e, 0x96, 0x4d, 0xe9, 0x87,
	0xbe, 0x0f, 0xb9, 0x7e, 0x7f, 0x4f, 0x43, 0x17, 0x73, 0xa7, 0x3e, 0xc8, 0x85, 0x5a, 0x1b, 0x7b,
	0x78, 0x48, 0x09, 0x98, 0xd7, 0xf2, 0x6c, 0x62, 0x5b, 0xe6, 0x48, 0xb6, 0xb3, 0x03, 0x8a, 0x6a,
	0x57, 0x2e, 0x16, 0xf5, 0x9c, 0x70, 0xe8, 0xbb, 0x50, 0x7c, 0xc4, 0xb9, 0xf1, 0x72, 0x23, 0xb3,
	0x3e, 0xdb, 0xbc, 0x42, 0xbd, 0xff, 0x78, 0x56, 0x2f, 0x71, 0xa9, 0xcf, 0x4b, 0x90, 0x0f, 0xf4,
	0x7f, 0xe6, 0x61, 0x49, 0x78, 0xb7, 0xf1, 0x81, 0xed, 0xd8, 0x8c, 0xb8, 0xfd, 0x1f, 0xe4, 0x77,
	0x6d, 0x67, 0x20, 0x0e, 0xe5, 0xc2, 0xd7, 0x67, 0x75, 0xd9, 0xa5, 0xa9, 0xd8, 0x60, 0x4a, 0x46,
	0x5d, 0xda, 0x02, 0x3a, 0x28, 0xc8, 0x23, 0x71, 0xfe, 0x24, 0xbd, 0xa1, 0x27, 0x0f, 0x41, 0x9e,
	0xb5, 0xfa, 0x3c, 0x6b, 0xf5, 0xec, 0x37, 0xed, 0xb4, 0x12, 0xf2, 0x0b, 0x9c, 0x20, 0x49, 0xb0,
	0xbf, 0x1f, 0x81, 0xdc, 0x1b, 0x71, 0xda, 0x12, 0x4e, 0x30, 0xc4, 0x5f, 0x81, 0xbc, 0x1f, 0x41,
	0x7e, 0xdf, 0xf5, 0x08, 0x3b, 0x65, 0x85, 0x66, 0x49, 0xc2, 0x0e, 0x13, 0xa2, 0x4d, 0x28, 0x30,
	0x8c, 0x10, 0x6c, 0x20, 0x84, 0xe4, 0x00, 0x88, 0x04, 0x17, 0xe0, 0x66, 0x68, 0x03, 0x8a, 0xec,
	0x87, 0xaf, 0x55, 0xd8, 0x44, 0x52, 0x1c, 0x0c, 0x61, 0x81, 0x36, 0x02, 0xa0, 0x14, 0xbc, 0x60,
	0x31, 0x30, 0x16, 0x72, 0x23, 0x40, 0xd2, 0xe0, 0x3a, 0x51, 0x55, 0xaf, 0x13, 0x37, 0x61, 0xe9,
	0xa1, 0x63, 0x3e, 0x1f, 0x51, 0x02, 0xf4, 0xe4, 0x04, 0x7b, 0x9e, 0x3d, 0xc0, 0xec, 0x64, 0x95,
	0x8d, 0xa4, 0x02, 0x6d, 0xc0, 0xe2, 0xbe, 0xe7, 0x9e, 0x4e, 0xdb, 0xd8, 0x27, 0xb6, 0xc3, 0x39,
	0x3a, 0x3b, 0x5e, 0x46, 0x42, 0x8e, 0xee, 0x40, 0x81, 0xc9, 0xd8, 0x21, 0xab, 0x6e, 0x7f, 0x14,
	0x2e, 0x83, 0x33, 0x1b, 0xa6, 0x6c, 0xb9, 0xce, 0x81, 0x3d, 0x34, 0xb8, 0x25, 0xba, 0x13, 0xb2,
	0xa0, 0x05, 0xe6, 0xf4, 0x41, 0x7c, 0x13, 0x84, 0x3a, 0xa0, 0x47, 0x97, 0xef, 0x31, 0xbf, 0xc8,
	0xc3, 0xd5, 0x47, 0xd8, 0x1c, 0x91, 0x43, 0x96, 0x4b, 0xa5, 0xfc, 0x74, 0x81, 0xa7, 0xbc, 0xfc,
	0xe6, 0xdf, 0x9e, 0xd5, 0xe1, 0xa6, 0x7b, 0x6c, 0x13, 0x7c, 0x3c, 0x26, 0x53, 0x81, 0xac, 0x77,
	0xe3, 0x00, 0x90, 0x65, 0x00, 0x10, 0x37, 0x8e, 0x41, 0xc1, 0xa7, 0xc1, 0xd9, 0xc8, 0xb1, 0xb3,
	0x71, 0x3d, 0x79, 0x36, 0x54, 0x6f, 0x61, 0x8c, 0xd6, 0x02, 0x18, 0xcf, 0xa7, 0x4e, 0x49, 0x02,
	0x7a, 0x83, 0x03, 0x7a, 0x21, 0xd5, 0x88, 0x41, 0x7b, 0x57, 0x81, 0xf6, 0xe2, 0x79, 0xe7, 0x7e,
	0x45, 0x9c, 0x7b, 0x25, 0x4a, 0x0c, 0xe4, 0x77, 0x43, 0x68, 0x2b, 0x5d, 0x36, 0x5a, 0x00, 0x72,
	0xd3, 0x73, 0x91, 0xaa, 0x7c, 0xd9, 0x6f, 0x9c, 0x13, 0x58, 0xff, 0x4f, 0x0e, 0xaa, 0x4a, 0x2d,
	0x04, 0x84, 0x31, 0x93, 0x20, 0x8c, 0x0a, 0x65, 0xc8, 0xfe, 0xcf, 0x28, 0x43, 0xee, 0x3d, 0x94,
	0x21, 0xff, 0x3e, 0xca, 0x50, 0x48, 0x52, 0x86, 0x6b, 0x50, 0x7c, 0x32, 0x21, 0xe3, 0x09, 0x89,
	0xd0, 0x01, 0x21, 0xa3, 0x5d, 0x59, 0x2c, 0xbc, 0xd3, 0x8e, 0x70, 0x82, 0x50, 0x8c, 0xd6, 0xa2,
	0x17, 0x2d, 0x95, 0x1e, 0x44, 0xae, 0x5b, 0x6b, 0xd1, 0xeb, 0x54, 0x45, 0x61, 0x27, 0x91, 0x4b,
	0xd5, 0x53, 0x80, 0xf0, 0x70, 0x09, 0x98, 0xaa, 0x05, 0xe7, 0x3a, 0xf5, 0x08, 0x36, 0xaf, 0xca,
	0x96, 0x13, 0xe5, 0xa7, 0x4a, 0xa0, 0x28, 0xdb, 0xad, 0x7e, 0x3b, 0xb6, 0xab, 0xbf, 0xca, 0x42,
	0xf9, 0xe9, 0xd8, 0x27, 0x1e, 0x36, 0x8f, 0xd1, 0x3a, 0x2c, 0x28, 0x38, 0x46, 0xf1, 0x56, 0x20,
	0x4a, 0x5c, 0x8c, 0xb6, 0x61, 0x59, 0x11, 0xd1, 0xac, 0xf8, 0x63, 0xd3, 0x92, 0x60, 0x93, 0xaa,
	0x8b, 0x45, 0x57, 0x5a, 0x56, 0x5c, 0x1c, 0xbb, 0x71, 0xe7, 0x13, 0x37, 0xee, 0x0d, 0x58, 0xdc,
	0x73, 0x2d, 0x73, 0xd4, 0xb4, 0x9d, 0x41, 0xb4, 0xa5, 0x25, 0xe4, 0xe8, 0x16, 0xcc, 0x05, 0x32,
	0xd6, 0xaa, 0x8a, 0xd1, 0x56, 0x15, 0xd5, 0xa2, 0x7b, 0x50, 0xe4, 0xc8, 0xcc, 0x8a, 0x64, 0xb6,
	0x59, 0x17, 0x40, 0x05, 0x4f, 0x1d, 0x5a, 0xcb, 0x83, 0xae, 0x39, 0x8e, 0xe6, 0x52, 0x98, 0x3f,
	0x28, 0xbf, 0xf8, 0x6d, 0x7d, 0xe6, 0xe7, 0x7f, 0x6a, 0xcc, 0xe8, 0x7f, 0xcf, 0x02, 0x4a, 0x22,
	0x3d, 0xfa, 0x1e, 0xac, 0x28, 0xeb, 0x54, 0x0b, 0x8d, 0xe7, 0xf8, 0x1d, 0xda, 0x58, 0xaa, 0xc3,
	0x22, 0x4e, 0xa6, 0x3a, 0xac, 0xe4, 0xdb, 0x70, 0x85, 0x2d, 0x2b, 0x76, 0xa7, 0xe7, 0xe9, 0x4e,
	0x53, 0xa1, 0x4f, 0x44, 0x4a, 0x85, 0x98, 0x65, 0x2a, 0x1f, 0xcd, 0x54, 0xc2, 0x00, 0x3d, 0x0c,
	0x92, 0x55, 0x60, 0xc9, 0xba, 0x95, 0x4c, 0x56, 0x14, 0x93, 0x52, 0x53, 0x87, 0x5a, 0x50, 0x91,
	0x25, 0xe8, 0x0b, 0x0e, 0xb2, 0x14, 0x14, 0xb4, 0xd4, 0x34, 0x51, 0x12, 0xe2, 0x8c, 0xd0, 0x4f,
	0xff, 0x47, 0x06, 0xae, 0x27, 0xf8, 0x8a, 0xba, 0x0d, 0x68, 0x9d, 0xf6, 0xd8, 0xe3, 0x63, 0x93,
	0xf1, 0xab, 0x5c, 0x4a, 0xa3, 0x90, 0x6a, 0xb4, 0x01, 0xe5, 0x87, 0xa7, 0xd8, 0xea, 0x86, 0x57,
	0xe7, 0xb8, 0x69, 0xa0, 0x47, 0xf7, 0x83, 0x1c, 0xf0, 0xce, 0xd6, 0x38, 0x2f, 0x07, 0xe9, 0xcb,
	0xce, 0x5f, 0x72, 0xd9, 0x2f, 0x33, 0xc1, 0xcb, 0x8d, 0x7c, 0x37, 0x59, 0x81, 0xe2, 0x63, 0x93,
	0xd8, 0x27, 0xbc, 0xb0, 0xca, 0x86, 0x18, 0xa1, 0x5d, 0x49, 0x4b, 0xf8, 0x2b, 0xf0, 0xda, 0xbb,
	0x69, 0x9e, 0x9a, 0xb6, 0xf8, 0x53, 0x85, 0x20, 0x2c, 0x9f, 0xc3, 0x7c, 0xcf, 0x1e, 0x60, 0xcb,
	0xf4, 0xe4, 0x1d, 0x86, 0x3f, 0xb4, 0xae, 0xbe, 0x3b, 0x6a, 0x3c, 0x52, 0x2c, 0x80, 0xfe, 0xbb,
	0x0c, 0x2c, 0x32, 0x38, 0x94, 0xd5, 0x4f, 0xd3, 0xfb, 0x1d, 0xa5, 0x21, 0x55, 0xb7, 0xe7, 0x22,
	0xaf, 0x01, 0x91, 0xfe, 0x74, 0x17, 0x4a, 0x72, 0x26, 0xd9, 0xd8, 0xe3, 0x13, 0xd5, 0x0b, 0x9d,
	0x7c, 0xe6, 0x08, 0xaf, 0x57, 0x92, 0x72, 0xe6, 0xd8, 0x06, 0x2c, 0xa7, 0xc1, 0xb3, 0x6c, 0x25,
	0xdc, 0x52, 0xff, 0x77, 0x01, 0xaa, 0x4a, 0x48, 0x74, 0x27, 0x42, 0xda, 0xaf, 0x47, 0xf7, 0x2a,
	0x9d, 0xc2, 0x2f, 0x87, 0x14, 0x5e, 0x04, 0xa7, 0x44, 0xbe, 0x16, 0x2e, 0x21, 0xf2, 0x26, 0x23,
	0x3f, 0xa4, 0xa9, 0xa4, 0x5e, 0x2e, 0x9e, 0x75, 0x9a, 0x5a, 0x8c, 0xda, 0xc7, 0x5f, 0x73, 0xa2,
	0x04, 0xbf, 0x96, 0x96, 0x99, 0x77, 0x3c, 0xad, 0xd4, 0x23, 0x04, 0x3f, 0xf2, 0xb6, 0xc0, 0x49,
	0xfe, 0xed, 0x90, 0x88, 0x97, 0xd3, 0x89, 0xb8, 0x9c, 0x8c, 0xa4, 0xe3, 0xdb, 0x69, 0xc4, 0xbb,
	0xa2, 0x5c, 0x23, 0x53, 0xe8, 0xf7, 0x8f, 0x52, 0xe8, 0x37, 0xbf, 0x5b, 0x2f, 0x25, 0xdb, 0x5b,
	0x92, 0x91, 0xdf, 0x93, 0xa5, 0x5f, 0x3d, 0x97, 0x91, 0xcb, 0x2b, 0x09, 0x2f, 0xf3, 0x7b, 0x21,
	0x2f, 0x9f, 0x7d, 0x2f, 0x2f, 0x17, 0x6e, 0xc1, 0xe3, 0xa5, 0x01, 0xab, 0x0c, 0x2e, 0x47, 0x53,
	0x43, 0xf0, 0x2f, 0x3c, 0xd8, 0xf1, 0x45, 0xc5, 0xb3, 0x9b, 0x43, 0xb9, 0x89, 0xde, 0x9e, 0xd5,
	0x33, 0xb7, 0xa2, 0x73, 0x7f, 0x8f, 0x57, 0xb4, 0xf1, 0xcf, 0x7f, 0xcb, 0x67, 0xae, 0x4b, 0x5f,
	0x1f, 0xbe, 0xca, 0x80, 0xc6, 0x42, 0xe0, 0x41, 0xfc, 0xb4, 0xfa, 0xe8, 0x53, 0x4a, 0xd0, 0x06,
	0xd8, 0x67, 0x08, 0x4b, 0x19, 0x6b, 0xe4, 0x06, 0xa7, 0x98, 0xca, 0x34, 0x73, 0xb7, 0x07, 0xca,
	0xff, 0xb3, 0xc4, 0xf1, 0x45, 0xd1, 0x77, 0x5e, 0xaa, 0x51, 0x1e, 0x79, 0x43, 0x73, 0xfd, 0x37,
	0x19, 0x98, 0xdd, 0xa7, 0x84, 0x58, 0x5c, 0x25, 0xd0, 0x0f, 0x41, 0xde, 0x2a, 0xc4, 0x2c, 0xc2,
	0xc7, 0x48, 0xd5, 0x6e, 0x53, 0xfc, 0xe5, 0xd7, 0x59, 0xe9, 0xb2, 0xfa, 0x04, 0x66, 0x55, 0x45,
	0x4a, 0x6a, 0x3e, 0x56, 0x53, 0x53, 0xdd, 0xbe, 0x12, 0x56, 0x04, 0xf1, 0x6c, 0x67, 0xb8, 0x67,
	0xfb, 0x44, 0xcd, 0xd7, 0x0d, 0x80, 0x50, 0x41, 0xc1, 0xf9, 0x0b, 0xaa, 0xe2, 0x73, 0xab, 0x18,
	0x62, 0xd4, 0x6c, 0xbc, 0xfc, 0x6b, 0x6d, 0xe6, 0xe5, 0xeb, 0x5a, 0xe6, 0xd5, 0xeb, 0x5a, 0xe6,
	0x2f, 0xaf, 0x6b, 0x99, 0x5f, 0xbe, 0xa9, 0xcd, 0xbc, 0x78, 0x53, 0x9b, 0x79, 0xf5, 0xa6, 0x36,
	0xf3, 0x87, 0x37, 0xb5, 0x99, 0xe7, 0x45, 0xc6, 0xfa, 0x3f, 0xf9, 0x6f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x4e, 0xfa, 0xcf, 0xed, 0x64, 0x1c, 0x00, 0x00,
}
